/*
 * IdeaMap.java
 *
 * Created on August 31, 2006, 6:03 PM
 *
 * Copyright (c) 2006, David Griffiths
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of David Griffiths nor the names of his contributors
 *   may be used to endorse or promote products derived from this software
 *   without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

package dg.hipster.view;

import dg.hipster.controller.IdeaMapController;
import dg.hipster.model.Idea;
import dg.inx.XMLPanel;
import java.awt.BasicStroke;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.Stroke;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.Point2D;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JLayeredPane;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.SpringLayout;
import javax.swing.Timer;

/**
 * Main component for displaying the mind maps.
 * @author davidg
 */
public final class IdeaMap extends JComponent implements MapComponent {
    /**
     * Proportion that the image will be scaled in and out each
     * time the {@link #zoomIn()} and {@link #zoomOut()} methods are called.
     */
    public final static double SCALE_FACTOR = 1.5;
    /**
     * Controller object for this idea map.
     */
    private IdeaMapController controller;
    /**
     * Idea that will appear at the centre of the map.
     */
    private CentreView rootView;
    /**
     * Currently selected idea branch (if any).
     */
    private IdeaView selected;
    /**
     * Text field that appears at the top of the component.
     */
    private JTextField text;
    /**
     * Amount this map is scaled.
     */
    private double zoom = 1.0;
    /**
     * Amount to offset the map by.
     */
    private Point offset;
    /**
     * Index to be applied to next autogenerated idea name
     * (eg 3 for &quot;New 3&quot;).
     */
    private int newCount = 0;
    /**
     * Default background colour.
     */
    private static final Color DEFAULT_BACKGROUND = new Color(95, 95, 95);
    /**
     * Content pane where the map is displayed.
     */
    private JLayeredPane mapArea;
    private FloatingPanel propertiesPanel;
    /**
     * Pause between animation updates. 40 = 20 fps.
     */
    private static final int REFRESH_PAUSE = 50; // milliseconds
    /**
     * Timer that updates the edited text.
     */
    private Timer ticker = new Timer(REFRESH_PAUSE, new ActionListener() {
        public void actionPerformed(final ActionEvent evt) {
            repaint();
        }
    });
    
    /** Creates a new instance of Fred */
    public IdeaMap() {
        text = new JTextField("");
        setLayout(new BorderLayout());
        add(text, BorderLayout.NORTH);
        controller = new IdeaMapController(this);
        setBackground(DEFAULT_BACKGROUND);
        JLayeredPane mapArea = new JLayeredPane();
        mapArea.setBackground(new Color(0, 0, 0, 0));
        add(mapArea, BorderLayout.CENTER);
        propertiesPanel = new FloatingPanel();
        propertiesPanel.setCaption("Properties");
        propertiesPanel.setBounds(50, 50, 200, 200);
        JLabel labTest = new JLabel("Test");
        labTest.setForeground(null);
        propertiesPanel.getContentPane().add(labTest);
        mapArea.add(propertiesPanel);
        this.setPropertiesVisible(false);
    }
    
    /**
     * Text field that appears at the top of the component.
     * @return Text field that appears at the top of the component.
     */
    public JTextField getTextField() {
        return this.text;
    }
    
    /**
     * Set the central newIdea of the map.
     *
     * @param newIdea Idea that will be displayed at the centre.
     */
    public void setIdea(Idea newIdea) {
        Idea oldIdea = getIdea();
        if ((newIdea != null) && (!newIdea.equals(oldIdea))) {
            this.rootView = new CentreView(newIdea);
            this.rootView.setParent(this);
            rootView.setSelected(true);
            this.selected = rootView;
            text.setText(newIdea.getText());
            text.setEnabled(false);
        }
        this.resetView();
    }
    
    /**
     * Currently selected idea branch (if any).
     * @return Currently selected idea branch (if any).
     */
    public Idea getSelected() {
        return this.selected.getIdea();
    }
    
    /**
     * Currently selected idea branch (if any).
     * @param selectedIdea Currently selected idea branch (if any).
     */
    public void setSelected(Idea selectedIdea) {
        setSelectedView(findIdeaViewFor(rootView, selectedIdea));
    }
    
    /**
     * Find the view (if any) that represents the given idea.
     * Start the search at the given view, and search all of
     * it's sub-views.
     * @param parentView View to start the search at.
     * @param idea idea we are looking for.
     * @return idea-view representing the idea, or null
     * if none are found.
     */
    private IdeaView findIdeaViewFor(IdeaView parentView, Idea idea) {
        if (idea == null) {
            return null;
        }
        if (parentView.getIdea().equals(idea)) {
            return parentView;
        }
        for (IdeaView subView: parentView.getSubViews()) {
            IdeaView ideaView = findIdeaViewFor(subView, idea);
            if (ideaView != null) {
                return ideaView;
            }
        }
        return null;
    }
    
    /**
     * Currently selected idea branch (if any).
     * @return Currently selected idea branch (if any).
     */
    public IdeaView getSelectedView() {
        return this.selected;
    }
    
    /**
     * Select the given view.
     * @param newSelectedView View to select.
     */
    public void setSelectedView(IdeaView newSelectedView) {
        if (this.selected != null) {
            this.selected.setSelected(false);
        }
        this.selected = newSelectedView;
        if (this.selected != null) {
            this.selected.setSelected(true);
            propertiesPanel.getContentPane().removeAll();
            propertiesPanel.getContentPane().add(new XMLPanel(
                    newSelectedView.getIdea(),
                    "/dg/hipster/view/ideaProperties.xml"));
            propertiesPanel.auto();
            this.setPropertiesVisible(this.getPropertiesVisible());
            if (propertiesVisible) {
                propertiesPanel.setVisible(false);
                propertiesPanel.setVisible(true);
            }
        } else {
            propertiesPanel.setVisible(false);
        }
    }
    
    /**
     * The idea represented at the centre of this map.
     * @return central idea.
     */
    public Idea getIdea() {
        if (this.rootView != null) {
            return this.rootView.getIdea();
        }
        return null;
    }
    
    /**
     * The idea-view at the centre of this map.
     * @return idea-view at the centre of this map.
     */
    public IdeaView getRootView() {
        return this.rootView;
    }
    
    /**
     * Paint the map part of the component (the text-field
     * will paint itself).
     * @param gOrig Graphics object to draw on.
     */
    public void paintComponent(Graphics gOrig) {
        Dimension size = getSize();
        gOrig.setColor(this.getBackground());
        gOrig.fillRect(0, 0, size.width, size.height);
        Graphics g = gOrig.create();
        ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                RenderingHints.VALUE_ANTIALIAS_ON);
        g.setColor(Color.BLACK);
        g.translate(size.width / 2, size.height / 2);
        if (offset != null) {
            g.translate(offset.x, offset.y);
        }
        ((Graphics2D)g).scale(zoom, zoom);
        if (rootView != null) {
            rootView.paint(g, this);
        }
        g.dispose();
        if ((rubberBandFrom != null) && (rubberBandTo != null)) {
            this.drawRubberBand((Graphics2D)gOrig);
        }
    }
    
    /**
     * Amount this map is scaled.
     * @return  Amount this map is scaled.
     */
    public double getZoom() {
        return zoom;
    }
    
    /**
     * Scale this map up by the given factor.
     */
    public void zoom(double factor) {
        zoom *= factor;
        offset.x *= factor;
        offset.y *= factor;
        repaint();
    }
    
    /**
     * Scale this map up by {@link #SCALE_FACTOR}.
     */
    public void zoomIn() {
        zoom(SCALE_FACTOR);
    }
    
    /**
     * Scale this map down by {@link #SCALE_FACTOR}.
     */
    public void zoomOut() {
        zoom(1.0 / SCALE_FACTOR);
    }
    
    /**
     * Call for a repaint of this map.
     */
    public void adjust() {
        controller.adjust();
    }
    
    /**
     * Call for a repaint of this map.
     */
    public void startAdjust() {
        controller.startAdjust();
    }
    
    /**
     * Get the controller for this map.
     */
    public IdeaMapController getController() {
        return this.controller;
    }
    
    public Point getOffset() {
        return offset;
    }
    
    public void setOffset(Point offset) {
        this.offset = offset;
        repaint();
    }
    
    /**
     * 2D point in map space corresponding to the given point in screen space.
     *@param p Point in screen space.
     *@return Point2D in map space.
     */
    public Point2D getMapPoint(Point p) {
        Dimension size = getSize();
        double x = p.x - (size.width / 2);
        double y = p.y - (size.height / 2);
        if (offset != null) {
            x -= offset.x;
            y -= offset.y;
        }
        double z = zoom;
        x /= z;
        y /= z;
        return new Point2D.Double(x, y);
    }
    
    /**
     * Point in screen space corresponding to the given point in map space.
     *@param p Point2D in map space.
     *@return Point in screen space.
     */
    public Point getScreenPoint(Point2D p) {
        Dimension size = getSize();
        double x = p.getX();
        double y = p.getY();
        double z = zoom;
        x *= z;
        y *= z;
        if (offset != null) {
            x += offset.x;
            y += offset.y;
        }
        x += (size.width / 2);
        y += (size.height / 2);
        return new Point((int)x, (int)y);
    }
    
    /**
     * Reset the zoom and offset.
     */
    public void resetView() {
        centreView();
        resetZoom();
        setPropertiesVisible(false);
    }
    
    /**
     * Centre the view.
     */
    public void centreView() {
        offset = new Point(0, 0);
        //repaintRequired();
        repaint();
    }
    
    /**
     * Centre the view.
     */
    public void resetZoom() {
        offset.x /= zoom;
        offset.y /= zoom;
        zoom = 1.0;
        //repaintRequired();
        repaint();
    }
    
    /**
     * Insert a child branch to the currently selected idea (do nothing
     * if none selected).
     */
    public void insertChild() {
        final IdeaView selected = getSelectedView();
        if (selected == null) {
            return;
        }
        Idea newIdea = new Idea("New " + (newCount++));
        selected.getIdea().add(0, newIdea);
        editIdeaView(selected.getSubViews().get(0));
    }
    
    public void editIdeaView(final IdeaView selected) {
        selectIdeaView(selected);
        selected.setEditing(true);
        text.setEnabled(true);
        text.requestFocusInWindow();
        text.selectAll();
        ticker.start();
    }
    
    public void selectIdeaView(final IdeaView selected) {
        setSelectedView(selected);
        text.setText(selected.getIdea().getText());
    }
    
    public void insertIdea() {
        final IdeaView selected = getSelectedView();
        if (selected == null) {
            return;
        }
        MapComponent parent = selected.getParent();
        if (!(parent instanceof IdeaView)) {
            return;
        }
        IdeaView parentView = (IdeaView) parent;
        int pos = parentView.getSubViews().indexOf(selected);
        Idea newIdea = new Idea("New " + (newCount++));
        parentView.getIdea().add(pos + 1, newIdea);
        editIdeaView(selected.getNextSibling());
    }
    
    public void unEditIdeaView(final IdeaView ideaView) {
        ideaView.getIdea().setText(text.getText());
        ideaView.setEditing(false);
        text.select(0, 0);
        text.setEnabled(false);
        ticker.stop();
    }
    
    public void deleteSelected() {
        final IdeaView selected = getSelectedView();
        if (selected == null) {
            return;
        }
        MapComponent parent = selected.getParent();
        if (!(parent instanceof IdeaView)) {
            return;
        }
        IdeaView parentView = (IdeaView) parent;
        IdeaView nextToSelect = null;
        IdeaView nextSibling = selected.getNextSibling();
        IdeaView previousSibling = selected.getPreviousSibling();
        if (nextSibling != null) {
            nextToSelect = nextSibling;
        } else if (previousSibling != null) {
            nextToSelect = previousSibling;
        } else {
            nextToSelect = parentView;
        }
        parentView.getIdea().remove(selected.getIdea());
        selectIdeaView(nextToSelect);
    }
    
    public void dragBranchTo(final BranchView branch,
            final Point screenPoint) {
        Point2D p = getMapPoint(screenPoint);
        Point2D fromPoint = branch.getFromPoint();
        MapComponent parent = branch.getParent();
        if (parent instanceof CentreView) {
            CentreView centre = (CentreView) parent;
            double x = p.getX();
            x = x * centre.ROOT_RADIUS_Y / centre.ROOT_RADIUS_X;
            p.setLocation(x, p.getY());
            fromPoint = new Point2D.Double(0, 0);
        }
        double angle = getAngleBetween(fromPoint, p);
        if (parent instanceof IdeaView) {
            IdeaView parentView = (IdeaView) parent;
            angle = angle - parentView.getRealAngle();
        }
        angle = normalizeRange(angle);
        double oldAngle = branch.getIdea().getAngle();
        if (Math.abs(oldAngle - angle) < Math.PI) {
            branch.getIdea().setAngle(angle);
        }
        adjust();
    }
    
    private double normalizeRange(double angle) {
        while (angle < -Math.PI) {
            angle += 2 * Math.PI;
        }
        while (angle > Math.PI) {
            angle -= 2 * Math.PI;
        }
        return angle;
    }
    
    /**
     * The clockwise angle in radians of the line between
     * the given points. If toP is directly above fromP, the
     * angle is 0.0.
     * @param fromP start point of the line.
     * @param toP end point of the line.
     * @return clockwise angle in radians of the line.
     */
    static double getAngleBetween(final Point2D fromP, final Point2D toP) {
        double diffX = toP.getX() - fromP.getX();
        double diffY = toP.getY() - fromP.getY();
        double angle = 0.0;
        double tan = Math.abs(diffX) / Math.abs(diffY);
        angle = Math.atan(tan);
        if (diffY > 0) {
            angle = (Math.PI - angle);
        }
        if (diffX < 0) {
            angle *= -1;
        }
        return angle;
    }
    
    private Point rubberBandFrom;
    private Point rubberBandTo;
    
    public void drawLinkRubberBand(final Point toPoint) {
        IdeaView selectedView = getSelectedView();
        if ((selectedView == null) || (!(selectedView instanceof BranchView))) {
            return;
        }
        BranchView branch = (BranchView) selectedView;
        Point2D fromPoint = branch.getMidPoint();
        Point fp = getScreenPoint(fromPoint);
        Graphics2D g = (Graphics2D) getGraphics();
        rubberBandFrom = fp;
        rubberBandTo = toPoint;
        repaint();
    }
    
    public void clearRubberBand() {
        this.rubberBandFrom = null;
        this.rubberBandTo = null;
    }
    
    private void drawRubberBand(final Graphics2D g) {
        g.setColor(Color.GRAY);
        Dimension size = getSize();
        Stroke oldStroke = g.getStroke();
        float strokeWidth = BranchView.DEFAULT_STROKE_WIDTH;
        Stroke stroke = new BasicStroke(strokeWidth,
                BasicStroke.CAP_ROUND, BasicStroke.JOIN_BEVEL);
        g.setStroke(stroke);
        g.drawLine(rubberBandFrom.x, rubberBandFrom.y,
                rubberBandTo.x, rubberBandTo.y);
        g.setStroke(oldStroke);
    }
    
    public JLayeredPane getMapArea() {
        return mapArea;
    }
    
    private boolean propertiesVisible;
    public void setPropertiesVisible(boolean show) {
        if (this.getSelectedView() != null) {
            propertiesPanel.setVisible(show);
        }
        propertiesVisible = show;
    }
    
    public boolean getPropertiesVisible() {
        return this.propertiesVisible;
    }
    
    public void togglePropertiesPanel() {
        setPropertiesVisible(!getPropertiesVisible());
    }
}

final class FloatingPanel extends JPanel implements MouseListener,
        MouseMotionListener {
    private static Color SHADED = new Color(0, 0, 0, 95);
    private static Color CLEAR = new Color(0, 0, 0, 0);
    private JPanel contentPane;
    private JLabel title;
//    private JButton closeButton;
    
    FloatingPanel() {
        setBackground(new Color(0, 0, 0, 0));
        this.addMouseListener(this);
        this.addMouseMotionListener(this);
        SpringLayout layout = new SpringLayout();
        this.setLayout(layout);
        title = new JLabel("Test");
        title.setBackground(SHADED);
        title.setForeground(Color.WHITE);
        this.add(title);
        contentPane = new JPanel();
        contentPane.setBackground(CLEAR);
        contentPane.setForeground(Color.WHITE);
        this.add(contentPane);
        layout.putConstraint(SpringLayout.WEST, title, 10,
                SpringLayout.WEST, this);
        layout.putConstraint(SpringLayout.NORTH, title, 10,
                SpringLayout.NORTH, this);
        layout.putConstraint(SpringLayout.NORTH, contentPane, 10,
                SpringLayout.SOUTH, title);
        layout.putConstraint(SpringLayout.WEST, contentPane, 10,
                SpringLayout.WEST, this);
    }
    
    public void setCaption(String caption) {
        title.setText(caption);
    }
    
    public String getCaption() {
        return title.getText();
    }
    
    private Point downPoint;
    private Point start;
    public void mouseEntered(final MouseEvent evt) {
    }
    public void mouseExited(final MouseEvent evt) {
    }
    public void mouseClicked(final MouseEvent evt) {
    }
    public void mouseMoved(final MouseEvent evt) {
    }
    public void mouseReleased(final MouseEvent evt) {
        downPoint = null;
    }
    public void mousePressed(final MouseEvent evt) {
        downPoint = evt.getPoint();
        start = this.getLocation();
        downPoint = evt.getPoint();
        downPoint.x += start.x;
        downPoint.y += start.y;
    }
    public void mouseDragged(final MouseEvent evt) {
        Point p = evt.getPoint();
        Point s = this.getLocation();
        int xDiff = s.x + p.x - downPoint.x;
        int yDiff = s.y + p.y - downPoint.y;
        setLocation(new Point(start.x + xDiff, start.y + yDiff));
    }
    
    public void paintComponent(Graphics g) {
        g.setColor(SHADED);
        Dimension size = getSize();
        g.fillRoundRect(0, 0, size.width, size.height, 10, 10);
        g.setColor(Color.GRAY.darker());
        g.drawLine(5, 0, size.width - 5, 0);
        g.setColor(Color.BLACK);
        g.drawLine(5, size.height - 1,
                size.width - 5, size.height - 1);
    }
    
    public void auto() {
        Dimension panSize = contentPane.getPreferredSize();
        setSize(panSize.width + 20, panSize.height + 50);
    }
    
    public JPanel getContentPane() {
        return contentPane;
    }
}
